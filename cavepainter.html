<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lascaux Cave Painting</title>
    <style>
        :root {
            --color-background: #1a1612;
            --color-surface: #2a2420;
            --color-text: #e8dcc8;
            --color-ochre-yellow: #d4a574;
            --color-ochre-red: #8b4513;
            --color-charcoal: #3a3a3a;
            --color-white: #f5ebe0;
            --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-base);
            background: var(--color-background);
            color: var(--color-text);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: crosshair;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(42, 36, 32, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(212, 165, 116, 0.3);
            backdrop-filter: blur(10px);
            z-index: 100;
            max-width: 300px;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 15px;
            color: var(--color-ochre-yellow);
        }

        .tool-section {
            margin-bottom: 20px;
        }

        .tool-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--color-text);
            font-weight: 600;
        }

        .brush-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .btn {
            padding: 10px 14px;
            border: 2px solid rgba(212, 165, 116, 0.3);
            background: rgba(58, 58, 58, 0.6);
            color: var(--color-text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            flex: 1;
        }

        .btn:hover {
            background: rgba(212, 165, 116, 0.2);
            border-color: var(--color-ochre-yellow);
        }

        .btn.active {
            background: var(--color-ochre-yellow);
            color: #1a1612;
            border-color: var(--color-ochre-yellow);
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }

        .color-btn {
            width: 100%;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: var(--color-white);
            box-shadow: 0 0 10px rgba(245, 235, 224, 0.5);
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: var(--color-text);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(212, 165, 116, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--color-ochre-yellow);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--color-ochre-yellow);
            cursor: pointer;
            border: none;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-action {
            padding: 10px;
            border: 2px solid rgba(212, 165, 116, 0.3);
            background: rgba(139, 69, 19, 0.3);
            color: var(--color-text);
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn-action:hover {
            background: rgba(139, 69, 19, 0.5);
            border-color: var(--color-ochre-red);
        }

        #help-button {
            position: fixed;
            right: 70px;
            bottom: 12px;
            width: 50px;
            height: 50px;
            background: rgba(94, 82, 64, 0.6);
            border: 2px solid #8B7355;
            border-radius: 50%;
            font-size: 1.5rem;
            color: #E8DCC8;
            cursor: pointer;
            z-index: 120;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #help-button:hover {
            background: rgba(94, 82, 64, 0.9);
            border-color: #DAA520;
            transform: scale(1.1);
        }

        #instructions-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 22, 18, 0.95);
            padding: 30px;
            border-radius: 12px;
            border: 2px solid var(--color-ochre-yellow);
            font-size: 14px;
            max-width: 400px;
            z-index: 200;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
        }

        #instructions-modal.visible {
            display: block;
        }

        #instructions-modal h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--color-ochre-yellow);
            font-size: 18px;
        }

        #instructions-modal ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #instructions-modal li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }

        #instructions-modal li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: var(--color-ochre-yellow);
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: var(--color-ochre-yellow);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--color-white);
        }

        #modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 150;
            display: none;
        }

        #modal-overlay.visible {
            display: block;
        }
        
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            cursor: pointer;
        }
        
        #start-overlay.hidden {
            display: none;
        }
        
        #start-message {
            background: rgba(26, 22, 18, 0.95);
            padding: 40px 60px;
            border-radius: 12px;
            border: 2px solid var(--color-ochre-yellow);
            text-align: center;
            font-size: 18px;
            color: var(--color-ochre-yellow);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }
        
        #start-message h2 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        
        #start-message p {
            margin: 0;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <!-- Start overlay -->
    <div id="start-overlay">
        <div id="start-message">
            <h2>Welcome to the Cave</h2>
            <p>Click anywhere to start painting</p>
        </div>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="info-panel">
        <h1>üé® Lascaux Cave Art</h1>
        
        <div class="tool-section">
            <h3>Painting Tools</h3>
            <div class="brush-buttons">
                <button class="btn active" data-brush="brush">Brush</button>
                <button class="btn" data-brush="finger">Finger</button>
                <button class="btn" data-brush="spray">Spray</button>
            </div>
        </div>

        <div class="tool-section">
            <h3>Prehistoric Pigments</h3>
            <div class="color-palette">
                <button class="color-btn active" data-color="#d4a574" style="background: #d4a574;" title="Yellow Ochre"></button>
                <button class="color-btn" data-color="#8b4513" style="background: #8b4513;" title="Red Ochre"></button>
                <button class="color-btn" data-color="#3a3a3a" style="background: #3a3a3a;" title="Charcoal"></button>
                <button class="color-btn" data-color="#f5ebe0" style="background: #f5ebe0;" title="Kaolin White"></button>
                <button class="color-btn" data-color="#a0826d" style="background: #a0826d;" title="Brown Ochre"></button>
                <button class="color-btn" data-color="#6b4423" style="background: #6b4423;" title="Dark Brown"></button>
                <button class="color-btn" data-color="#4a4a4a" style="background: #4a4a4a;" title="Gray"></button>
                <button class="color-btn" data-color="#2a1810" style="background: #2a1810;" title="Burnt Umber"></button>
            </div>
        </div>

        <div class="tool-section">
            <div class="slider-group">
                <label for="brush-size">Brush Size: <span id="size-value">15</span>px</label>
                <input type="range" id="brush-size" min="5" max="80" value="15">
            </div>
            <div class="slider-group">
                <label for="opacity">Opacity: <span id="opacity-value">80</span>%</label>
                <input type="range" id="opacity" min="10" max="100" value="80">
            </div>
        </div>

        <div class="action-buttons">
            <button class="btn-action" id="clear-btn">Clear Canvas</button>
            <button class="btn-action" id="export-png">Export PNG</button>
            <button class="btn-action" id="export-gltf">Export glTF (GLB)</button>
        </div>
    </div>

    <!-- Help Button -->
    <button id="help-button" title="Controls">‚ùì</button>

    <!-- Modal Overlay -->
    <div id="modal-overlay"></div>

    <!-- Instructions Modal -->
    <div id="instructions-modal">
        <button class="modal-close">&times;</button>
        <h2>Cave Painting Controls</h2>
        <ul>
            <li><strong>Left Click + Drag</strong> - Paint on the cave wall</li>
            <li><strong>WASD</strong> - Move around the cave</li>
            <li><strong>Arrow Keys</strong> - Look around (rotate camera)</li>
            <li><strong>Q/E</strong> - Move down/up vertically</li>
            <li><strong>Mouse Wheel</strong> - Zoom in/out</li>
            <li><strong>Right Click + Drag</strong> - Free look (alternative camera rotation)</li>
            <li><strong>Color Buttons</strong> - Select paint color</li>
            <li><strong>Brush/Spray</strong> - Change painting tool</li>
            <li><strong>Clear</strong> - Erase all paintings</li>
            <li><strong>Export</strong> - Save your art as 3D model</li>
        </ul>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script>
        // Prevent click sounds on canvas painting
        let canvasClickSoundEnabled = false;
        
        // Scene setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a08);
        scene.fog = new THREE.Fog(0x0a0a08, 5, 20);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 2.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Painting state
        let currentBrush = 'brush';
        let currentColor = '#d4a574';
        let brushSize = 15;
        let opacity = 0.8;
        let isDrawing = false;
        let lastPoint = null;

        // Create limestone cave texture
        function createCaveTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');

            // Base limestone color - lighter, more authentic to Lascaux
            ctx.fillStyle = '#c9baa8';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add variations and texture with lighter limestone tones
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 20 + 5;
                const colors = ['#d4c5b3', '#bfb09e', '#cfc0ae', '#b8a897', '#ddd0be'];
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add subtle cracks and details
            ctx.strokeStyle = '#a89885';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 50; i++) {
                ctx.beginPath();
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * canvas.height;
                ctx.moveTo(startX, startY);
                for (let j = 0; j < 5; j++) {
                    ctx.lineTo(startX + (Math.random() - 0.5) * 100, startY + Math.random() * 100);
                }
                ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        }

        // Create painting canvas
        const paintCanvas = document.createElement('canvas');
        paintCanvas.width = 2048;
        paintCanvas.height = 2048;
        const paintCtx = paintCanvas.getContext('2d');
        paintCtx.fillStyle = 'rgba(0, 0, 0, 0)';
        paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
        const paintTexture = new THREE.CanvasTexture(paintCanvas);

        // Create 3D cave wall with rough limestone texture
        function create3DCaveWall() {
            const caveTexture = createCaveTexture();
            
            // Create a rough 3D cave wall surface using displaced geometry
            const wallWidth = 4;
            const wallHeight = 3;
            const segments = 40;
            
            const geometry = new THREE.PlaneGeometry(wallWidth, wallHeight, segments, segments);
            const vertices = geometry.attributes.position;
            
            // Add roughness and variation to create 3D limestone texture
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                const z = vertices.getZ(i);
                
                // Create varied depth using noise-like function
                let displacement = Math.sin(x * 3) * 0.05 + Math.cos(y * 4) * 0.04;
                displacement += Math.sin(x * 7 + y * 5) * 0.03;
                displacement += (Math.random() - 0.5) * 0.08;
                
                // Create smoother patches (for painting)
                const smoothPatchSize = 0.8;
                const patchX = 0;
                const patchY = 0;
                const distanceFromPatch = Math.sqrt(Math.pow(x - patchX, 2) + Math.pow(y - patchY, 2));
                
                if (distanceFromPatch < smoothPatchSize) {
                    const smoothFactor = 1 - (distanceFromPatch / smoothPatchSize);
                    displacement *= (1 - smoothFactor * 0.7);
                }
                
                vertices.setZ(i, z + displacement);
            }
            
            geometry.computeVertexNormals();
            
            const caveMaterial = new THREE.MeshStandardMaterial({
                map: caveTexture,
                roughness: 0.95,
                metalness: 0.05,
                bumpMap: caveTexture,
                bumpScale: 0.02
            });
            
            const caveWall = new THREE.Mesh(geometry, caveMaterial);
            caveWall.position.set(0, 0, -1);
            scene.add(caveWall);
            
            // Create painting surface overlay on the 3D wall
            const paintGeometry = new THREE.PlaneGeometry(wallWidth, wallHeight, segments, segments);
            const paintVertices = paintGeometry.attributes.position;
            
            // Match the cave wall displacement EXACTLY so paint follows the 3D surface
            for (let i = 0; i < paintVertices.count; i++) {
                paintVertices.setZ(i, vertices.getZ(i) + 0.005); // Slightly in front to avoid z-fighting
            }
            
            paintGeometry.computeVertexNormals();
            
            const paintingSurface = new THREE.Mesh(
                paintGeometry,
                new THREE.MeshStandardMaterial({
                    map: paintTexture,
                    transparent: true,
                    opacity: 1,
                    side: THREE.DoubleSide,
                    roughness: 0.95,
                    metalness: 0,
                    depthWrite: true,
                    depthTest: true
                })
            );
            paintingSurface.position.copy(caveWall.position);
            paintingSurface.position.z += 0.002;
            paintingSurface.name = 'paintingSurface';
            scene.add(paintingSurface);
            
            // Add surrounding cave environment with organic curved surfaces
            const envTexture = createCaveTexture();
            
            // Create much larger organic floor with displacement that rises toward canvas
            const floorGeometry = new THREE.PlaneGeometry(24, 18, 80, 60);
            const floorVertices = floorGeometry.attributes.position;
            
            for (let i = 0; i < floorVertices.count; i++) {
                const x = floorVertices.getX(i);
                const y = floorVertices.getY(i);
                const z = floorVertices.getZ(i);
                
                // Create organic cave floor with dips and rises
                let displacement = Math.sin(x * 0.5) * 0.15 + Math.cos(y * 0.7) * 0.12;
                displacement += Math.sin(x * 1.2 + y * 1.5) * 0.08;
                displacement += Math.sin(x * 2.5) * Math.cos(y * 2.3) * 0.05;
                displacement += (Math.random() - 0.5) * 0.1;
                
                // Rise smoothly toward the canvas wall (positive y direction)
                if (y > 0) {
                    displacement += Math.pow(y / 9, 2) * 0.5;
                }
                
                // Rise to meet the canvas bottom - canvas is at z=-1 in world coords
                const distToCanvasX = Math.abs(x);
                const distToCanvasZ = Math.abs(y - 1.0); // Adjust to target canvas position correctly
                if (distToCanvasX < 3.0 && distToCanvasZ < 0.8) {
                    const distToCanvas = Math.sqrt(Math.pow(distToCanvasX / 3.0, 2) + Math.pow(distToCanvasZ / 0.8, 2));
                    if (distToCanvas < 1) {
                        displacement += (1 - distToCanvas) * 0.8; // Raising floor to cover bottom edge
                    }
                }
                
                // Slight slope toward edges
                const distFromCenter = Math.sqrt(x * x + y * y);
                displacement -= distFromCenter * 0.015;
                
                floorVertices.setZ(i, z + displacement);
            }
            
            floorGeometry.computeVertexNormals();
            
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: envTexture,
                roughness: 0.95,
                metalness: 0.05,
                bumpMap: envTexture,
                bumpScale: 0.03
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2.0; // Lower floor for more headroom
            scene.add(floor);
            
            // Create much larger organic ceiling with stalactites that lowers toward canvas
            const ceilingGeometry = new THREE.PlaneGeometry(24, 18, 80, 60);
            const ceilingVertices = ceilingGeometry.attributes.position;
            
            for (let i = 0; i < ceilingVertices.count; i++) {
                const x = ceilingVertices.getX(i);
                const y = ceilingVertices.getY(i);
                const z = ceilingVertices.getZ(i);
                
                // Create rough ceiling with stalactite formations
                let displacement = Math.sin(x * 0.8) * 0.2 + Math.cos(y * 0.6) * 0.18;
                displacement += Math.sin(x * 2.0 + y * 1.8) * 0.12;
                displacement += Math.sin(x * 3.5) * Math.cos(y * 3.2) * 0.08;
                
                // Lower ceiling smoothly toward the canvas wall (positive y direction)
                if (y > 0) {
                    displacement -= Math.pow(y / 9, 2) * 0.5;
                }
                
                // Lower to meet the canvas top - canvas is at z=-1 in world coords
                const distToCanvasX = Math.abs(x);
                const distToCanvasZ = Math.abs(z - (-1.0)); // or simply Math.abs(z + 1.0)
                if (distToCanvasX < 4.0 && distToCanvasZ < 1.5) {
                    const distToCanvas = Math.sqrt(Math.pow(distToCanvasX / 2.0, 2) + Math.pow(distToCanvasZ / 0.8, 2));
                    if (distToCanvas < 1) {
                        displacement -= (0 - distToCanvas) * -1.3; // Lowering ceiling to cover top edge
                    }
                }
                
                // Add random stalactite-like protrusions
                if (Math.random() > 0.92) {
                    displacement -= Math.random() * 0.25;
                }
                
                displacement += (Math.random() - 0.5) * 0.15;
                
                ceilingVertices.setZ(i, z + displacement);
            }
            
            ceilingGeometry.computeVertexNormals();
            
            const ceilingTexture = createCaveTexture();
            ceilingTexture.wrapS = THREE.RepeatWrapping;
            ceilingTexture.wrapT = THREE.RepeatWrapping;
            ceilingTexture.repeat.set(4, 3);
            
            const ceilingBump = createCaveTexture();
            ceilingBump.wrapS = THREE.RepeatWrapping;
            ceilingBump.wrapT = THREE.RepeatWrapping;
            ceilingBump.repeat.set(4, 3);
            
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                map: ceilingTexture,
                roughness: 0.85,
                metalness: 0.02,
                bumpMap: ceilingBump,
                bumpScale: 0.08,
                color: '#d4c5b3' // Lighter limestone tone
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 1.5; // Lowered ceiling to cover canvas top
            scene.add(ceiling);
            
            // Create larger curved back wall
            const backWallGeometry = new THREE.PlaneGeometry(20, 5, 70, 35);
            const backVertices = backWallGeometry.attributes.position;
            
            for (let i = 0; i < backVertices.count; i++) {
                const x = backVertices.getX(i);
                const y = backVertices.getY(i);
                const z = backVertices.getZ(i);
                
                // Create rough, organic wall texture with multiple scales of detail
                let displacement = -Math.pow(x / 5, 2) * 0.8; // Parabolic curve
                // Large waves
                displacement += Math.sin(x * 0.8) * 0.4 + Math.cos(y * 0.6) * 0.35;
                displacement += Math.sin(x * 2.0 + y * 1.8) * 0.25;
                // Medium detail
                displacement += Math.sin(x * 3.5) * Math.cos(y * 3.2) * 0.15;
                displacement += Math.sin(x * 5.5 + y * 4.3) * 0.08;
                // Small irregular bumps
                displacement += Math.sin(x * 8.2) * Math.cos(y * 7.5) * 0.05;
                displacement += Math.sin(x * 12.3 + y * 11.7) * 0.03;
                // Random variation
                displacement += (Math.random() - 0.5) * 0.2;
                
                backVertices.setZ(i, z + displacement);
            }
            
            backWallGeometry.computeVertexNormals();
            
            const backWallTexture = createCaveTexture();
            backWallTexture.wrapS = THREE.RepeatWrapping;
            backWallTexture.wrapT = THREE.RepeatWrapping;
            backWallTexture.repeat.set(5, 2);
            
            const backWallBump = createCaveTexture();
            backWallBump.wrapS = THREE.RepeatWrapping;
            backWallBump.wrapT = THREE.RepeatWrapping;
            backWallBump.repeat.set(5, 2);
            
            const backWallMaterial = new THREE.MeshStandardMaterial({
                map: backWallTexture,
                roughness: 0.85,
                metalness: 0.02,
                bumpMap: backWallBump,
                bumpScale: 0.08,
                color: '#d4c5b3' // Lighter limestone tone
            });
            
            const backWall = new THREE.Mesh(backWallGeometry, backWallMaterial);
            backWall.position.set(0, 0.2, -6); // Pushed further back
            scene.add(backWall);
            
            // Create larger curved left wall that touches the canvas edge
            const leftWallGeometry = new THREE.PlaneGeometry(12, 5, 60, 35);
            const leftVertices = leftWallGeometry.attributes.position;
            
            for (let i = 0; i < leftVertices.count; i++) {
                const x = leftVertices.getX(i);
                const y = leftVertices.getY(i);
                const z = leftVertices.getZ(i);
                
                // Create rough, organic wall texture with multiple scales of detail
                let displacement = Math.pow((x + 3) / 6, 3) * 2.5; // Stronger curve toward front
                // Large waves
                displacement += Math.sin(x * 0.8) * 0.3 + Math.cos(y * 0.6) * 0.28;
                displacement += Math.sin(x * 2.0 + y * 1.8) * 0.2;
                // Medium detail
                displacement += Math.sin(x * 3.5) * Math.cos(y * 3.2) * 0.12;
                displacement += Math.sin(x * 5.5 + y * 4.3) * 0.07;
                // Small irregular bumps
                displacement += Math.sin(x * 8.2) * Math.cos(y * 7.5) * 0.04;
                displacement += Math.sin(x * 12.3 + y * 11.7) * 0.025;
                // Random variation
                displacement += (Math.random() - 0.5) * 0.18;
                
                leftVertices.setZ(i, z + displacement);
            }
            
            leftWallGeometry.computeVertexNormals();
            
            const leftWallTexture = createCaveTexture();
            leftWallTexture.wrapS = THREE.RepeatWrapping;
            leftWallTexture.wrapT = THREE.RepeatWrapping;
            leftWallTexture.repeat.set(3, 2);
            
            const leftWallBump = createCaveTexture();
            leftWallBump.wrapS = THREE.RepeatWrapping;
            leftWallBump.wrapT = THREE.RepeatWrapping;
            leftWallBump.repeat.set(3, 2);
            
            const leftWallMaterial = new THREE.MeshStandardMaterial({
                map: leftWallTexture,
                roughness: 0.85,
                metalness: 0.02,
                bumpMap: leftWallBump,
                bumpScale: 0.08,
                color: '#d4c5b3' // Lighter limestone tone
            });
            
            const leftWall = new THREE.Mesh(leftWallGeometry, leftWallMaterial);
            leftWall.position.set(-8, 0.2, 0); // Pushed further out to the side
            leftWall.rotation.y = Math.PI / 2;
            scene.add(leftWall);
            
            // Create larger curved right wall that touches the canvas edge
            const rightWallGeometry = new THREE.PlaneGeometry(12, 5, 60, 35);
            const rightVertices = rightWallGeometry.attributes.position;
            
            for (let i = 0; i < rightVertices.count; i++) {
                const x = rightVertices.getX(i);
                const y = rightVertices.getY(i);
                const z = rightVertices.getZ(i);
                
                // Create rough, organic wall texture with multiple scales of detail - mirror of left wall
                let displacement = Math.pow((x + 3) / 6, 3) * 2.5; // Stronger curve toward front
                // Large waves
                displacement += Math.sin(x * 0.8) * 0.3 + Math.cos(y * 0.6) * 0.28;
                displacement += Math.sin(x * 2.0 + y * 1.8) * 0.2;
                // Medium detail
                displacement += Math.sin(x * 3.5) * Math.cos(y * 3.2) * 0.12;
                displacement += Math.sin(x * 5.5 + y * 4.3) * 0.07;
                // Small irregular bumps
                displacement += Math.sin(x * 8.2) * Math.cos(y * 7.5) * 0.04;
                displacement += Math.sin(x * 12.3 + y * 11.7) * 0.025;
                // Random variation
                displacement += (Math.random() - 0.5) * 0.18;
                
                rightVertices.setZ(i, z + displacement);
            }
            
            rightWallGeometry.computeVertexNormals();
            
            const rightWallTexture = createCaveTexture();
            rightWallTexture.wrapS = THREE.RepeatWrapping;
            rightWallTexture.wrapT = THREE.RepeatWrapping;
            rightWallTexture.repeat.set(3, 2);
            
            const rightWallBump = createCaveTexture();
            rightWallBump.wrapS = THREE.RepeatWrapping;
            rightWallBump.wrapT = THREE.RepeatWrapping;
            rightWallBump.repeat.set(3, 2);
            
            const rightWallMaterial = new THREE.MeshStandardMaterial({
                map: rightWallTexture,
                roughness: 0.85,
                metalness: 0.02,
                bumpMap: rightWallBump,
                bumpScale: 0.08,
                color: '#d4c5b3' // Lighter limestone tone
            });
            
            const rightWall = new THREE.Mesh(rightWallGeometry, rightWallMaterial);
            rightWall.position.set(8, 0.2, 0); // Pushed further out to the side
            rightWall.rotation.y = -Math.PI / 2;
            scene.add(rightWall);
            
            // Create smooth curved backside behind the canvas
            // This creates a rounded alcove that wraps around behind the painting surface
            const canvasBackGeometry = new THREE.SphereGeometry(3, 32, 32, 0, Math.PI, 0, Math.PI);
            const canvasBackVertices = canvasBackGeometry.attributes.position;
            
            for (let i = 0; i < canvasBackVertices.count; i++) {
                const x = canvasBackVertices.getX(i);
                const y = canvasBackVertices.getY(i);
                const z = canvasBackVertices.getZ(i);
                
                // Add organic displacement
                let displacement = Math.sin(x * 4) * 0.08 + Math.cos(y * 3) * 0.06;
                displacement += (Math.random() - 0.5) * 0.1;
                
                const dist = Math.sqrt(x * x + y * y + z * z);
                const newDist = dist + displacement;
                const ratio = newDist / dist;
                
                canvasBackVertices.setX(i, x * ratio);
                canvasBackVertices.setY(i, y * ratio);
                canvasBackVertices.setZ(i, z * ratio);
            }
            
            canvasBackGeometry.computeVertexNormals();
            
            const canvasBackTexture = createCaveTexture();
            canvasBackTexture.wrapS = THREE.RepeatWrapping;
            canvasBackTexture.wrapT = THREE.RepeatWrapping;
            canvasBackTexture.repeat.set(2, 2);
            
            const canvasBackBump = createCaveTexture();
            canvasBackBump.wrapS = THREE.RepeatWrapping;
            canvasBackBump.wrapT = THREE.RepeatWrapping;
            canvasBackBump.repeat.set(2, 2);
            
            const canvasBack = new THREE.Mesh(canvasBackGeometry, new THREE.MeshStandardMaterial({
                map: canvasBackTexture,
                roughness: 0.85,
                metalness: 0.02,
                bumpMap: canvasBackBump,
                bumpScale: 0.08,
                color: '#d4c5b3', // Lighter limestone tone
                side: THREE.FrontSide
            }));
            canvasBack.position.set(0, 0, -1);
            canvasBack.rotation.y = Math.PI;
            canvasBack.scale.set(0.7, 0.6, 0.5);
            scene.add(canvasBack);
            
            // Add rock formations on floor
            const rockGeometry = new THREE.DodecahedronGeometry(0.2, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({
                map: createCaveTexture(),
                roughness: 0.95,
                metalness: 0.05
            });
            
            // Random rocks throughout the cave
            for (let i = 0; i < 35; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                rock.position.set(
                    (Math.random() - 0.5) * 20,
                    -2.0 + Math.random() * 0.15,
                    (Math.random() - 0.5) * 12
                );
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.set(
                    1 + Math.random() * 0.5, 
                    0.5 + Math.random() * 0.3, 
                    1 + Math.random() * 0.5
                );
                scene.add(rock);
            }
            
            // Extra rocks concentrated at the canvas base, especially left corner
            for (let i = 0; i < 15; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                // Position biased toward left side of canvas base
                const xPos = -2 + Math.random() * 3; // Concentrated on left (-2 to 1)
                const zPos = -0.5 + Math.random() * 1.5; // At canvas base
                rock.position.set(
                    xPos,
                    -1.9 + Math.random() * 0.1,
                    zPos
                );
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.set(
                    1 + Math.random() * 0.5, 
                    0.5 + Math.random() * 0.3, 
                    1 + Math.random() * 0.5
                );
                scene.add(rock);
            }
            
            // Add large rocks at the bottom corners of the canvas
            // Left corner - large rock cluster
            for (let i = 0; i < 6; i++) {
                const cornerRock = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                cornerRock.position.set(
                    -2.0 + (Math.random() - 0.5) * 0.6,
                    -1.7 + (i % 3) * 0.2,
                    -0.8 + (Math.random() - 0.5) * 0.4
                );
                cornerRock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                cornerRock.scale.set(
                    1.5 + Math.random() * 0.8,
                    0.8 + Math.random() * 0.5,
                    1.5 + Math.random() * 0.8
                );
                scene.add(cornerRock);
            }
            
            // Right corner - large rock cluster
            for (let i = 0; i < 3; i++) {
                const cornerRock = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                cornerRock.position.set(
                    2.0 + (Math.random() - 0.5) * 0.4,
                    -1.7 + i * 0.2,
                    -0.8 + (Math.random() - 0.5) * 0.3
                );
                cornerRock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                cornerRock.scale.set(
                    1.5 + Math.random() * 0.8,
                    0.8 + Math.random() * 0.5,
                    1.5 + Math.random() * 0.8
                );
                scene.add(cornerRock);
            }
            
            // Add more hanging formations (small stalactites)
            for (let i = 0; i < 15; i++) {
                const stalactite = new THREE.Mesh(
                    new THREE.ConeGeometry(0.05 + Math.random() * 0.08, 0.2 + Math.random() * 0.4, 8),
                    rockMaterial.clone()
                );
                stalactite.position.set(
                    (Math.random() - 0.5) * 18,
                    1.5 - Math.random() * 0.4,
                    (Math.random() - 0.5) * 12
                );
                stalactite.rotation.x = Math.PI;
                scene.add(stalactite);
            }
            
            // Add rounded transition elements where walls meet floor
            // These create a more organic cave feel
            
            // Left wall-floor transition
            for (let i = 0; i < 10; i++) {
                const transition = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                transition.position.set(
                    -7 + (Math.random() - 0.5) * 2,
                    -1.8,
                    (Math.random() - 0.5) * 10
                );
                transition.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                transition.scale.set(
                    1 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.3,
                    1 + Math.random() * 0.5
                );
                scene.add(transition);
            }
            
            // Right wall-floor transition
            for (let i = 0; i < 10; i++) {
                const transition = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                transition.position.set(
                    7 + (Math.random() - 0.5) * 2,
                    -1.8,
                    (Math.random() - 0.5) * 10
                );
                transition.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                transition.scale.set(
                    1 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.3,
                    1 + Math.random() * 0.5
                );
                scene.add(transition);
            }
            
            // Back wall-floor transition
            for (let i = 0; i < 15; i++) {
                const transition = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                transition.position.set(
                    (Math.random() - 0.5) * 18,
                    -1.8,
                    -5 + (Math.random() - 0.5) * 2
                );
                transition.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                transition.scale.set(
                    1 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.3,
                    1 + Math.random() * 0.5
                );
                scene.add(transition);
            }
            
            // Canvas area wall-floor transitions (more concentrated around painting area)
            for (let i = 0; i < 8; i++) {
                const transition = new THREE.Mesh(rockGeometry, rockMaterial.clone());
                transition.position.set(
                    (Math.random() - 0.5) * 6,
                    -1.75,
                    -0.5 + (Math.random() - 0.5) * 2
                );
                transition.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                transition.scale.set(
                    0.8 + Math.random() * 0.4,
                    0.4 + Math.random() * 0.25,
                    0.8 + Math.random() * 0.4
                );
                scene.add(transition);
            }
        }

        create3DCaveWall();

        // Lighting - flickering torch effect
        const torchLight = new THREE.PointLight(0xff8844, 1.5, 10);
        torchLight.position.set(-1, 1, 1);
        torchLight.castShadow = true;
        scene.add(torchLight);

        const ambientLight = new THREE.AmbientLight(0x332211, 0.3);
        scene.add(ambientLight);

        // Animate torch flicker
        function animateTorch() {
            const flicker = Math.sin(Date.now() * 0.005) * 0.1 + Math.random() * 0.1;
            torchLight.intensity = 1.5 + flicker;
            torchLight.position.x = -1 + Math.sin(Date.now() * 0.002) * 0.2;
        }

        // Raycaster for painting
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Store the painting surface mesh for easier access
        let paintingSurfaceMesh = null;
        setTimeout(() => {
            paintingSurfaceMesh = scene.getObjectByName('paintingSurface');
        }, 100);

        // Drawing functions
        function drawBrush(x, y) {
            paintCtx.globalCompositeOperation = 'source-over';
            paintCtx.fillStyle = currentColor;
            paintCtx.globalAlpha = opacity;
            paintCtx.beginPath();
            paintCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
            paintCtx.fill();
        }

        function drawFinger(x, y) {
            paintCtx.globalCompositeOperation = 'source-over';
            paintCtx.fillStyle = currentColor;
            paintCtx.globalAlpha = opacity * 0.6;
            const size = brushSize * 1.2;
            paintCtx.beginPath();
            paintCtx.ellipse(x, y, size / 2, size / 1.5, Math.random() * Math.PI, 0, Math.PI * 2);
            paintCtx.fill();
        }

        function drawSpray(x, y) {
            paintCtx.globalCompositeOperation = 'source-over';
            paintCtx.fillStyle = currentColor;
            const sprayRadius = brushSize * 2;
            const density = 30;
            
            for (let i = 0; i < density; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * sprayRadius;
                const px = x + Math.cos(angle) * distance;
                const py = y + Math.sin(angle) * distance;
                const size = Math.random() * 3 + 1;
                paintCtx.globalAlpha = opacity * (0.1 + Math.random() * 0.3);
                paintCtx.beginPath();
                paintCtx.arc(px, py, size, 0, Math.PI * 2);
                paintCtx.fill();
            }
        }

        function paint(event) {
            if (!paintingSurfaceMesh) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(paintingSurfaceMesh);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (intersect.object.name === 'paintingSurface') {
                    const uv = intersect.uv;
                    const x = uv.x * paintCanvas.width;
                    const y = (1 - uv.y) * paintCanvas.height;

                    if (lastPoint && isDrawing) {
                        const dx = x - lastPoint.x;
                        const dy = y - lastPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const steps = Math.max(1, Math.floor(distance / 5));

                        for (let i = 0; i <= steps; i++) {
                            const ix = lastPoint.x + (dx / steps) * i;
                            const iy = lastPoint.y + (dy / steps) * i;
                            
                            switch (currentBrush) {
                                case 'brush':
                                    drawBrush(ix, iy);
                                    break;
                                case 'finger':
                                    drawFinger(ix, iy);
                                    break;
                                case 'spray':
                                    drawSpray(ix, iy);
                                    break;
                            }
                        }
                    } else {
                        switch (currentBrush) {
                            case 'brush':
                                drawBrush(x, y);
                                break;
                            case 'finger':
                                drawFinger(x, y);
                                break;
                            case 'spray':
                                drawSpray(x, y);
                                break;
                        }
                    }

                    lastPoint = { x, y };
                    paintTexture.needsUpdate = true;
                }
            }
        }

        // Event listeners
        renderer.domElement.addEventListener('mousedown', (e) => {
            canvasClickSoundEnabled = false; // Disable click sound for canvas painting
            isDrawing = true;
            lastPoint = null;
            paint(e);
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                paint(e);
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDrawing = false;
            lastPoint = null;
            setTimeout(() => { canvasClickSoundEnabled = true; }, 50); // Re-enable after a short delay
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            isDrawing = false;
            lastPoint = null;
        });

        // Touch support
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            canvasClickSoundEnabled = false; // Disable click sound for canvas painting
            isDrawing = true;
            lastPoint = null;
            const touch = e.touches[0];
            paint({ clientX: touch.clientX, clientY: touch.clientY });
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const touch = e.touches[0];
                paint({ clientX: touch.clientX, clientY: touch.clientY });
            }
        });

        renderer.domElement.addEventListener('touchend', () => {
            isDrawing = false;
            lastPoint = null;
            setTimeout(() => { canvasClickSoundEnabled = true; }, 50); // Re-enable after a short delay
        });

        // UI Controls
        document.querySelectorAll('[data-brush]').forEach(btn => {
            btn.addEventListener('click', () => {
                // Send click sound message to parent
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'caveClickSound', enabled: true }, '*');
                }
                document.querySelectorAll('[data-brush]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentBrush = btn.dataset.brush;
            });
        });

        document.querySelectorAll('[data-color]').forEach(btn => {
            btn.addEventListener('click', () => {
                // Send click sound message to parent
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'caveClickSound', enabled: true }, '*');
                }
                document.querySelectorAll('[data-color]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentColor = btn.dataset.color;
            });
        });

        document.getElementById('brush-size').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('size-value').textContent = brushSize;
        });

        document.getElementById('opacity').addEventListener('input', (e) => {
            opacity = parseInt(e.target.value) / 100;
            document.getElementById('opacity-value').textContent = e.target.value;
        });

        document.getElementById('clear-btn').addEventListener('click', () => {
            // Send click sound message to parent
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'caveClickSound', enabled: true }, '*');
            }
            paintCtx.clearRect(0, 0, paintCanvas.width, paintCanvas.height);
            paintTexture.needsUpdate = true;
        });

        // PNG Export with lighting (high-resolution option)
        document.getElementById('export-png').addEventListener('click', () => {
            // Send click sound message to parent
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'caveClickSound', enabled: true }, '*');
            }
            
            // You can adjust `scale` to increase export resolution (2=2x, 3=3x, etc.)
            const scale = 3; // recommended: 2-4 depending on memory

            // Save current renderer and camera state
            const prevSize = renderer.getSize(new THREE.Vector2());
            const prevPixelRatio = renderer.getPixelRatio();
            const prevAspect = camera.aspect;

            const exportWidth = Math.max(1, Math.floor(prevSize.x * scale));
            const exportHeight = Math.max(1, Math.floor(prevSize.y * scale));

            try {
                // Resize renderer for high-res render. Use pixelRatio=1 to avoid double-scaling.
                renderer.setPixelRatio(1);
                renderer.setSize(exportWidth, exportHeight, false);
                camera.aspect = exportWidth / exportHeight;
                camera.updateProjectionMatrix();

                // Render high-res frame
                renderer.render(scene, camera);

                // Extract PNG data
                const dataURL = renderer.domElement.toDataURL('image/png');

                // Trigger download (user-initiated click)
                const link = document.createElement('a');
                link.download = `lascaux-cave-painting@${scale}x.png`;
                link.href = dataURL;
                link.click();
            } catch (e) {
                console.error('High-res export failed, falling back to current resolution', e);
                // Fallback: render at current size and download
                renderer.render(scene, camera);
                const dataURL = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'lascaux-cave-painting.png';
                link.href = dataURL;
                link.click();
            } finally {
                // Restore renderer and camera state
                renderer.setSize(prevSize.x, prevSize.y, false);
                renderer.setPixelRatio(prevPixelRatio);
                camera.aspect = prevAspect;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
            }
        });

        // OBJ export removed ‚Äî use glTF/GLB export instead

            // glTF (GLB) Export: composite cave + paint into an albedo texture and export the painting surface as a GLB
            document.getElementById('export-gltf').addEventListener('click', () => {
                // Send click sound message to parent
                if (window.parent !== window) {
                    window.parent.postMessage({ type: 'caveClickSound', enabled: true }, '*');
                }
                
                if (!paintingSurfaceMesh) return;

                // Find a cave texture in the scene (first mesh with a map that isn't the painting surface)
                let caveMap = null;
                scene.traverse((child) => {
                    if (child.isMesh && child.name !== 'paintingSurface' && child.material && child.material.map) {
                        caveMap = child.material.map;
                    }
                });

                // Composite cave + paint into one canvas (albedo/baseColor)
                const compCanvas = document.createElement('canvas');
                compCanvas.width = paintCanvas.width;
                compCanvas.height = paintCanvas.height;
                const compCtx = compCanvas.getContext('2d');

                if (caveMap && caveMap.image) {
                    try {
                        compCtx.drawImage(caveMap.image, 0, 0, compCanvas.width, compCanvas.height);
                    } catch (e) {
                        compCtx.fillStyle = '#c9baa8';
                        compCtx.fillRect(0, 0, compCanvas.width, compCanvas.height);
                    }
                } else {
                    compCtx.fillStyle = '#c9baa8';
                    compCtx.fillRect(0, 0, compCanvas.width, compCanvas.height);
                }

                compCtx.drawImage(paintCanvas, 0, 0, compCanvas.width, compCanvas.height);

                // Create a THREE texture from composite canvas
                const compositeTexture = new THREE.CanvasTexture(compCanvas);

                // Prepare export mesh (clone geometry and assign composite material)
                const exportGeometry = paintingSurfaceMesh.geometry.clone();
                const exportMaterial = new THREE.MeshStandardMaterial({
                    map: compositeTexture,
                    roughness: 0.95,
                    metalness: 0,
                    side: THREE.DoubleSide
                });
                const exportMesh = new THREE.Mesh(exportGeometry, exportMaterial);

                // Optionally bake lighting into a texture that matches the surface UVs,
                // then export as binary GLB. We'll render the surface with an ortho camera
                // aligned to the painting surface into a WebGLRenderTarget sized like the paint canvas.

                async function bakeSurfaceLightingToDataURL(surfaceMesh, width, height) {
                    // Create render target
                    const target = new THREE.WebGLRenderTarget(width, height, {
                        format: THREE.RGBAFormat,
                        type: THREE.UnsignedByteType,
                        depthBuffer: true
                    });

                    // Compute surface center and approximate normal
                    const bbox = new THREE.Box3().setFromObject(surfaceMesh);
                    const center = new THREE.Vector3();
                    bbox.getCenter(center);
                    const normal = new THREE.Vector3();
                    surfaceMesh.getWorldDirection(normal).normalize();

                    // Create a temporary orthographic camera positioned in front of the surface
                    const orthoCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 100);

                    // Position camera slightly in front of surface center along normal
                    const camPos = new THREE.Vector3().copy(center).addScaledVector(normal, 1.0);
                    orthoCam.position.copy(camPos);

                    // Align camera to look at the surface center and align up vector to the surface's local Y
                    const localY = new THREE.Vector3(0, 1, 0);
                    const worldYPoint = localY.clone();
                    surfaceMesh.localToWorld(worldYPoint);
                    const surfaceOrigin = surfaceMesh.getWorldPosition(new THREE.Vector3());
                    const worldY = worldYPoint.sub(surfaceOrigin);
                    if (worldY.lengthSq() === 0) worldY.set(0, 1, 0);
                    orthoCam.up.copy(worldY).normalize();

                    orthoCam.lookAt(center);
                    orthoCam.updateMatrixWorld();

                    // Build view matrix (camera space) for projecting world points
                    const viewMatrix = new THREE.Matrix4();
                    viewMatrix.getInverse(orthoCam.matrixWorld);

                    // Transform all surface vertex positions into camera space to compute extents
                    const posAttr = surfaceMesh.geometry.attributes.position;
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    const tmpLocal = new THREE.Vector3();
                    const tmpWorld = new THREE.Vector3();
                    const tmpCam = new THREE.Vector3();

                    for (let i = 0; i < posAttr.count; i++) {
                        tmpLocal.fromArray(posAttr.array, i * 3);
                        tmpWorld.copy(tmpLocal);
                        surfaceMesh.localToWorld(tmpWorld);
                        tmpCam.copy(tmpWorld).applyMatrix4(viewMatrix);
                        minX = Math.min(minX, tmpCam.x);
                        maxX = Math.max(maxX, tmpCam.x);
                        minY = Math.min(minY, tmpCam.y);
                        maxY = Math.max(maxY, tmpCam.y);
                    }

                    // Slight padding
                    const padX = (maxX - minX) * 0.02 || 0.01;
                    const padY = (maxY - minY) * 0.02 || 0.01;
                    minX -= padX; maxX += padX; minY -= padY; maxY += padY;

                    // Set orthographic extents to tightly fit the surface in camera space
                    orthoCam.left = minX;
                    orthoCam.right = maxX;
                    orthoCam.top = maxY;
                    orthoCam.bottom = minY;
                    orthoCam.near = 0.01;
                    orthoCam.far = 100;
                    orthoCam.updateProjectionMatrix();

                    // Save original render target
                    const origTarget = renderer.getRenderTarget();

                    // Render scene into target using the ortho camera
                    renderer.setRenderTarget(target);
                    renderer.setClearColor(0x000000, 0);
                    renderer.clear(true, true, true);
                    renderer.render(scene, orthoCam);
                    renderer.setRenderTarget(origTarget);

                    // Read pixels from render target
                    const readBuffer = new Uint8Array(width * height * 4);
                    try {
                        renderer.readRenderTargetPixels(target, 0, 0, width, height, readBuffer);
                    } catch (e) {
                        console.error('readRenderTargetPixels failed', e);
                        target.dispose();
                        return null;
                    }

                    // Flip Y while copying into ImageData because WebGL's origin is bottom-left
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.createImageData(width, height);

                    for (let y = 0; y < height; y++) {
                        const srcRow = height - 1 - y;
                        for (let x = 0; x < width; x++) {
                            const srcIdx = (srcRow * width + x) * 4;
                            const dstIdx = (y * width + x) * 4;
                            imageData.data[dstIdx] = readBuffer[srcIdx];
                            imageData.data[dstIdx + 1] = readBuffer[srcIdx + 1];
                            imageData.data[dstIdx + 2] = readBuffer[srcIdx + 2];
                            imageData.data[dstIdx + 3] = readBuffer[srcIdx + 3];
                        }
                    }

                    ctx.putImageData(imageData, 0, 0);
                    target.dispose();
                    return canvas.toDataURL('image/png');
                }

                // Bake at paint canvas resolution (or use a smaller/larger size)
                const bakeWidth = paintCanvas.width;
                const bakeHeight = paintCanvas.height;

                (async () => {
                    const bakedDataURL = await bakeSurfaceLightingToDataURL(paintingSurfaceMesh, bakeWidth, bakeHeight);
                    let finalTexture;
                    if (bakedDataURL) {
                        // Use baked lit texture
                        const img = new Image();
                        img.src = bakedDataURL;
                        await new Promise((res) => { img.onload = res; });
                        finalTexture = new THREE.CanvasTexture(img);
                    } else {
                        // Fallback to compositeTexture (unlit composite)
                        finalTexture = compositeTexture;
                    }

                    // Apply finalTexture to export material
                    exportMaterial.map = finalTexture;
                    exportMaterial.needsUpdate = true;

                    // Export as binary GLB
                    const exporter = new THREE.GLTFExporter();
                    exporter.parse(exportMesh, (result) => {
                        if (result instanceof ArrayBuffer) {
                            const blob = new Blob([result], { type: 'model/gltf-binary' });
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = 'lascaux.glb';
                            link.click();
                        } else {
                            // Fallback: save JSON glTF
                            const output = JSON.stringify(result, null, 2);
                            const blob = new Blob([output], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = 'lascaux.gltf';
                            link.click();
                        }
                    }, { binary: true });
                })();
            });

        // Camera controls
        let cameraRotation = { x: 0, y: 0 };
        const keys = {};

        // Ensure the document can receive keyboard events immediately
        document.body.setAttribute('tabindex', '0');
        document.body.focus(); // Focus immediately on script load
        window.focus(); // Also focus the window
        
        // Re-focus when clicking anywhere in the window
        window.addEventListener('click', () => {
            document.body.focus();
        });
        
        // Re-focus when mouse enters the window
        window.addEventListener('mouseenter', () => {
            document.body.focus();
        });

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse drag to look around
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 2 || e.ctrlKey) {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                cameraRotation.y += deltaX * 0.002;
                cameraRotation.x += deltaY * 0.002;
                cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x));
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Zoom with scroll
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(1, Math.min(5, camera.position.z));
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update camera rotation
            camera.rotation.y = cameraRotation.y;
            camera.rotation.x = cameraRotation.x;

            // Arrow keys for camera rotation (looking around)
            const rotateSpeed = 0.03;
            if (keys['arrowleft']) {
                cameraRotation.y += rotateSpeed;
            }
            if (keys['arrowright']) {
                cameraRotation.y -= rotateSpeed;
            }
            if (keys['arrowup']) {
                cameraRotation.x += rotateSpeed;
                cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x));
            }
            if (keys['arrowdown']) {
                cameraRotation.x -= rotateSpeed;
                cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x));
            }

            // WASD movement - full 3D freedom
            const moveSpeed = 0.05;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            
            if (keys['w']) {
                camera.position.add(forward.multiplyScalar(moveSpeed));
            }
            if (keys['s']) {
                camera.position.add(forward.multiplyScalar(-moveSpeed));
            }
            if (keys['a']) {
                camera.position.add(right.multiplyScalar(-moveSpeed));
            }
            if (keys['d']) {
                camera.position.add(right.multiplyScalar(moveSpeed));
            }
            if (keys['q']) {
                camera.position.y -= moveSpeed;
            }
            if (keys['e']) {
                camera.position.y += moveSpeed;
            }

            // Collision detection - prevent passing through surfaces
            // Floor collision (rises near canvas)
            const floorHeight = -1.5;
            if (camera.position.y < floorHeight + 0.5) {
                camera.position.y = floorHeight + 0.5;
            }
            
            // Ceiling collision (lowers near canvas)
            const ceilingHeight = 1.0;
            if (camera.position.y > ceilingHeight) {
                camera.position.y = ceilingHeight;
            }
            
            // Canvas wall collision - can't pass through the canvas/back area
            if (camera.position.z < -0.5 && Math.abs(camera.position.x) < 2.5) {
                camera.position.z = -0.5;
            }
            
            // Back wall collision
            if (camera.position.z < -5) {
                camera.position.z = -5;
            }
            
            // Side walls collision
            if (camera.position.x < -7.5) {
                camera.position.x = -7.5;
            }
            if (camera.position.x > 7.5) {
                camera.position.x = 7.5;
            }
            
            // Front boundary (viewer's starting area)
            if (camera.position.z > 6) {
                camera.position.z = 6;
            }

            animateTorch();
            renderer.render(scene, camera);
        }

        animate();

        // Ensure keyboard input works immediately - force focus after everything loads
        setTimeout(() => {
            document.body.focus();
            window.focus();
        }, 100);
        
        // Handle start overlay - dismiss on first click
        const startOverlay = document.getElementById('start-overlay');
        startOverlay.addEventListener('click', () => {
            startOverlay.classList.add('hidden');
            document.body.focus();
            window.focus();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Prevent context menu
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        // ========================================
        // HELP MODAL CONTROLS
        // ========================================
        
        const helpButton = document.getElementById('help-button');
        const instructionsModal = document.getElementById('instructions-modal');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalClose = document.querySelector('.modal-close');
        
        function openModal() {
            // Send click sound message to parent
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'caveClickSound', enabled: true }, '*');
            }
            instructionsModal.classList.add('visible');
            modalOverlay.classList.add('visible');
        }
        
        function closeModal() {
            // Send click sound message to parent
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'caveClickSound', enabled: true }, '*');
            }
            instructionsModal.classList.remove('visible');
            modalOverlay.classList.remove('visible');
        }
        
        helpButton.addEventListener('click', openModal);
        modalClose.addEventListener('click', closeModal);
        modalOverlay.addEventListener('click', closeModal);
        
        // Close on Escape key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && instructionsModal.classList.contains('visible')) {
                e.preventDefault();
                closeModal();
            }
        });

        // ========================================
        // GAME STATE INTEGRATION
        // ========================================
        
        // Notify parent that cave painter is ready
        if (window.parent !== window) {
            window.parent.postMessage({ type: 'cavePainterReady' }, '*');
        }
        
        // Listen for game state updates from parent
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'gameStateSync') {
                const { paints, tools } = event.data;
                
                // Update color palette based on available paints
                if (paints && Object.keys(paints).length > 0) {
                    updateColorPalette(paints);
                }
                
                // Update brush tools based on available tools
                if (tools) {
                    updateBrushTools(tools);
                }
            }
        });
        
        function updateColorPalette(paints) {
            const palette = document.querySelector('.color-palette');
            if (!palette) return;
            
            // Clear existing colors
            palette.innerHTML = '';
            
            // Add colors from crafted paints
            Object.keys(paints).forEach((key, index) => {
                const paint = paints[key];
                const btn = document.createElement('button');
                btn.className = 'color-btn' + (index === 0 ? ' active' : '');
                btn.dataset.color = paint.color;
                btn.style.background = paint.color;
                btn.title = paint.name;
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentColor = paint.color;
                });
                palette.appendChild(btn);
            });
            
            // Set first color as active
            if (Object.keys(paints).length > 0) {
                const firstPaint = paints[Object.keys(paints)[0]];
                currentColor = firstPaint.color;
            }
        }
        
        function updateBrushTools(tools) {
            const brushButtons = document.querySelector('.brush-buttons');
            if (!brushButtons) return;
            
            // Update button states based on available tools
            const fingerBtn = brushButtons.querySelector('[data-brush="finger"]');
            const brushBtn = brushButtons.querySelector('[data-brush="brush"]');
            const sprayBtn = brushButtons.querySelector('[data-brush="spray"]');
            
            // Finger is always available
            if (fingerBtn) {
                fingerBtn.disabled = false;
                fingerBtn.style.opacity = '1';
            }
            
            // Brush requires 'brush' tool
            if (brushBtn) {
                const hasBrush = tools && tools.brush;
                brushBtn.disabled = !hasBrush;
                brushBtn.style.opacity = hasBrush ? '1' : '0.3';
                if (!hasBrush) {
                    brushBtn.title = 'Craft a brush in the Workshop first!';
                }
            }
            
            // Spray requires 'sprayBone' tool
            if (sprayBtn) {
                const hasSpray = tools && tools.sprayBone;
                sprayBtn.disabled = !hasSpray;
                sprayBtn.style.opacity = hasSpray ? '1' : '0.3';
                if (!hasSpray) {
                    sprayBtn.title = 'Craft a spray bone in the Workshop first!';
                }
            }
        }
    </script>
</body>
</html>
